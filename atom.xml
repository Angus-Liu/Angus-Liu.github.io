<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://angus-liu.cn</id>
    <title>Angus的源部落</title>
    <updated>2020-09-28T07:26:43.659Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://angus-liu.cn"/>
    <link rel="self" href="https://angus-liu.cn/atom.xml"/>
    <subtitle>莫道儒冠误此生，从来诗书不负人</subtitle>
    <logo>https://angus-liu.cn/images/avatar.png</logo>
    <icon>https://angus-liu.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, Angus的源部落</rights>
    <entry>
        <title type="html"><![CDATA[RocketMQ 发送重试方案设计]]></title>
        <id>https://angus-liu.cn/post/rocketmq-fa-song-chong-shi-fang-an-she-ji/</id>
        <link href="https://angus-liu.cn/post/rocketmq-fa-song-chong-shi-fang-an-she-ji/">
        </link>
        <updated>2020-09-28T07:08:20.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://github.com/Angus-Liu/Notes/raw/master/Blog/assets/rocketmq_architecture.png" alt="img" loading="lazy"></figure>
<h2 id="基本概念">基本概念</h2>
<h3 id="消息类型">消息类型</h3>
<ul>
<li>普通消息：消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。</li>
<li>顺序消息：
<ul>
<li>分区顺序：对于指定 Topic，所有消息根据 sharding key 进行区块分区，在同一个分区内的消息按照 FIFO 进行发布和消费</li>
<li>全局顺序：对于指定 Topic，所有消息按照 FIFO 进行发布和消费</li>
</ul>
</li>
<li>事务消息：应用本地事务和发送消息操作可以被定义到全局事务中，提供类似 X/Open XA 的分布事务功能，通过事务消息能达到分布式事务的最终一致</li>
<li>定时消息：定时消息会暂存在名为 SCHEDULE_TOPIC_XXXX 的 topic 中，并根据 delayTimeLevel 存入特定的queue，broker 会调度地消费 SCHEDULE_TOPIC_XXXX，将消息写入真实的topic</li>
</ul>
<h3 id="发送方式-communicationmode通讯方式">发送方式 / CommunicationMode（通讯方式）</h3>
<ul>
<li>SYNC（同步）：producer 向 broker 发送消息，执行 API 时同步阻塞等待， 直到broker 服务器返回发送结果。</li>
<li>ASYNC（异步）：producer 向 broker 发送消息时指定消息发送成功及发送异常的回调方法，调用 API 后立即返回，producer 发送消息线程不阻塞 ，消息发送成功或失败的回调任务在一个新的线程中执行 。</li>
<li>ONEWAY（单向）：producer 向 broker 发送消息，执行 API 时直接返回，不等待broker 服务器的结果 。</li>
</ul>
<h3 id="发送状态">发送状态</h3>
<ul>
<li><strong>SEND_OK：消息发送成功</strong>。要注意的是消息发送成功也不意味着它是可靠的。要确保不会丢失任何消息，还应启用同步 Master 服务器或同步刷盘，即 SYNC_MASTER 或 SYNC_FLUSH。</li>
<li><strong>FLUSH_DISK_TIMEOUT：消息发送成功但是服务器刷盘超时。<strong>此时消息已经进入服务器队列（内存），只有服务器宕机，消息才会丢失。消息存储配置参数中可以设置刷盘方式和同步刷盘时间长度，如果Broker服务器设置了刷盘方式为同步刷盘，即FlushDiskType=SYNC_FLUSH（默认为异步刷盘方式），当Broker服务器未在同步刷盘时间内（默认为5s）完成刷盘，则将返回该状态——刷盘超时。</strong>(Broker 的刷盘策略设置成 SYNC_FLUSH 时才可能抛出这个错误，表示没有在规定时间内完成刷盘)</strong></li>
<li><strong>FLUSH_SLAVE_TIMEOUT：消息发送成功，但是服务器同步到Slave时超时</strong>。此时消息已经进入服务器队列，只有服务器宕机，消息才会丢失。如果Broker服务器的角色是同步Master，即SYNC_MASTER（默认是异步Master即ASYNC_MASTER），并且从Broker服务器未在同步刷盘时间（默认为5秒）内完成与主服务器的同步，则将返回该状态——数据同步到Slave服务器超时。<strong>（在 Broker 主从策略设置成 SYNC_MASTER 且没有在规定时间内完成主从同步时返回该状态）</strong></li>
<li><strong>SLAVE_NOT_AVAILABLE：消息发送成功，但是此时Slave不可用。<strong>如果Broker服务器的角色是同步Master，即SYNC_MASTER（默认是异步Master服务器即ASYNC_MASTER），但没有配置slave Broker服务器，则将返回该状态——无Slave服务器可用。</strong>（Broker 主从策略设置成 SYNC_MASTER时，若此时没有找到被配置成的 Slave 的 Broker，返回该状态）</strong></li>
<li>**Exception：**MQClientException（Producer 异常）、RemotingException（网络异常）、MQBrokerException（Broker 异常）、InterruptedException（发送线程中断异常）</li>
</ul>
<h2 id="背景">背景</h2>
<h3 id="线上异常">线上异常</h3>
<pre><code class="language-java">// 流控
org.apache.rocketmq.client.exception.MQBrokerException: CODE: 2  DESC: [REJECTREQUEST]system busy, start flow control for a while
    For more information, please visit the url, http://rocketmq.apache.org/docs/faq/
  
// 发送消息超时
org.apache.rocketmq.remoting.exception.RemotingTooMuchRequestException: sendDefaultImpl call timeout
</code></pre>
<h3 id="流控">流控</h3>
<blockquote>
<p>https://juejin.im/post/6844903957697921032</p>
<p>https://juejin.im/post/6844903989608185864</p>
</blockquote>
<p>当 broker 处理能力达到瓶颈时就会触发，生产者流控，此时 Producer 会直接忽略重试次数，不会尝试消息重投：</p>
<ul>
<li>PageCache 繁忙：commitLog文件被锁时间超过osPageCacheBusyTimeOutMills时，参数默认为1000ms，返回流控。</li>
<li>TransientStorePool 堆外内存不足：如果开启transientStorePoolEnable == true，且broker为异步刷盘的主机，且transientStorePool中资源不足，拒绝当前send请求，返回流控。</li>
<li>排队中的任务等待时间超过了200ms：broker每隔10ms检查send请求队列头部请求的等待时间，如果超过waitTimeMillsInSendQueue，默认200ms，拒绝当前send请求，返回流控。</li>
<li>其他：broker通过拒绝send 请求方式实现流量控制。</li>
</ul>
<h3 id="rocketmq-自身的发送重试">RocketMQ 自身的发送重试</h3>
<p><strong>Producer 的 send 方法本身支持内部重试：</strong></p>
<ul>
<li>
<p>同步发送：生产者会最多尝试发送 retryTimesWhenSendFailed + 1次。不会选择上次失败的broker，尝试向其他broker发送，最大程度保证消息不丢。超过重投次数或者超时，抛出异常，由客户端保证消息不丢失。当出现 RemotingException、MQClientException 和部分 MQBrokerException 时会重投。</p>
<p>代码：<code>DefaultMQProducerImpl.sendDefaultImpl 545</code></p>
</li>
<li>
<p>异步发送：生产者会最多尝试发送 retryTimesWhenSendAsyncFailed + 1次，异步重试不会选择其他broker，仅在同一个broker上做重试，不保证消息不丢。</p>
<p>代码：<code>MQClientAPIImpl.onExceptionImpl 584</code></p>
</li>
</ul>
<p>以上策略只是在一定程度上保证了消息可以发送成功。如果业务对消息可靠性要求比较高，应用需要增加相应的重试逻辑，确保消息一定到达Broker。</p>
<p><strong>为什么MQ客户端没有在内部集成 DB 重试方式，而是要求应用自己去完成：</strong></p>
<ul>
<li>MQ的客户端设计为无状态模式，方便任意的水平扩展，且对机器资源的消耗仅仅是cpu、内存、网络。</li>
<li>如果MQ客户端内部集成一个KV存储模块，那么数据只有同步落盘才能较可靠，而同步落盘本身性能开销较大，所以通常会采用异步落盘，又由于应用关闭过程不受MQ运维人员控制，可能经常会发生 kill -9 这样暴力方式关闭，造成数据没有及时落盘而丢失。</li>
<li>Producer所在机器的可靠性较低，一般为虚拟机，不适合存储重要数据。</li>
</ul>
<h2 id="方案选型">方案选型</h2>
<h3 id="方案考虑">方案考虑</h3>
<ol>
<li>重试成功率保证</li>
<li>重试策略制定：消息类型、Topic、次数、时间</li>
<li>对现有代码的改动性，侵入性</li>
<li>。。。</li>
</ol>
<h3 id="方案备选">方案备选</h3>
<ol>
<li>调整 RocketMQ 重试配置，增加发送重试次数（retryTimesWhenSendFailed/retryTimesWhenSendAsyncFailed）。平台提供的组件不支持直接修改，可以通过反射进行修改，或者直接使用 DefaultMQProducer。
<ul>
<li>优点：代码改动最小，对现有逻辑没有任何影响。</li>
<li>缺点：重试是立即执行的，不保证最终重试成功。特别是遇到流控时，RocketMQ 会忽略重试次数，直接返回发送失败。</li>
</ul>
</li>
<li>使用 <a href="https://github.com/spring-projects/spring-retry">spring-retry</a>，对发送方法进行失败重试。超过一定次数后，结合其他方法补偿。
<ul>
<li>优点：不结合其他方法时代码改动小，弥补了 1 中超时等情况 MQ 不进行重试的缺点，如果流控在短时间内结束时有一定效果。</li>
<li>缺点：重试是立即执行的，重试消息没有持久化，若不结合其他方法不保证最终重试成功。重试过程可能影响用户体验。</li>
</ul>
</li>
<li>消息发送失败时保存在内存中等待重新发送。根据重试策略，可使用 PriorityBlockingQueue、ArrayBlockingQueue 或 LinkedBlockingQueue 等。
<ul>
<li>优点：实现简单，代码改动小，不需要引入第三方组件。</li>
<li>缺点：当短时间内有大量消息需要重试时，该方法不适用；容器失效，消息直接丢失。</li>
</ul>
</li>
<li>借助 RocksDB：消息发送失败时保存在 RocksDB，以下次需要发送的时间等作为 key，同时启动多个线程从 RocksDB 取消息进行定时发送。
<ul>
<li>优点：弥补了方案3短时间内不能承接大量消息的不足</li>
<li>缺点：容器失效，消息直接丢失。</li>
</ul>
</li>
<li>借助 Redis：具体做法类似 RocksDB。
<ul>
<li>优点：容器失效，消息不会丢失。</li>
<li>缺点：增加了 Redis 压力。</li>
</ul>
</li>
<li>借助 MySQL：具体做法类似 RocksDB，消息 message id 作为唯一键，对发送时间做索引。
<ul>
<li>优点：确保消息不会丢失。消息被永久持久化。适用于数据高度敏感，消息需要入库的场景。</li>
<li>缺点： 增加了 MySQL 压力。</li>
</ul>
</li>
</ol>
<pre><code class="language-yuml">@startuml 

[*] -&gt; Producer

state c &lt;&lt;choice&gt;&gt;
Producer --&gt; c: 消息发送失败
c -&gt; Producer: 未超过重试次数

c --&gt; RocksDB: 超过重试次数
RocksDB: 消息发送失败存入RocksDB

Schedule --&gt; RocksDB
Schedule --&gt; Producer
Schedule: 定时扫描需要重发的消息

Producer -&gt; Broker
Broker -&gt; [*]

@enduml
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://github.com/Angus-Liu/Notes/blob/master/Blog/assets/image-20200917180555699.png" alt="image-20200917180555699" loading="lazy"></figure>
<pre><code class="language-puml">@startuml
component Producer as p
component Broker as b
component RetryComponent as r
database RocksDB as rdb
component RocksdbRetryManager as rrm {
    queue NeedRetryMessageQueue as nrmq
    agent RocksDB as rm
    component ReadMessageThread as rmt
    component ResendMessageThreads as rmts
}

p --&gt; b
p -&gt; r
rm -up-&gt; rdb
rmt -up-&gt; rdb
r -&gt; rm
rmt -up-&gt; nrmq
rmts -up-&gt; nrmq
rmts --&gt; p
rmts -up-&gt; rm
@enduml
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://github.com/Angus-Liu/Notes/raw/master/Blog/assets/RocksDB-Retry.png" alt="RocksDB Retry" loading="lazy"></figure>
<h2 id="重试和幂等">重试和幂等</h2>
<p>网络波动导致消息发送成功，但是 broker 没有返回发送成功状态，触发超时重试，这时候就需要实现消息幂等性，防止消息重复消费。解决办法有两个：</p>
<ol>
<li>业务上保证消息多次消费和第一次消费效果相同
<ul>
<li>Consumer 消费消息时根据消息内容进行各自具体逻辑判断，已消费的消息就直接返回消费成功</li>
</ul>
</li>
<li>在消息消费前统一检查消息是否被消费过
<ul>
<li>将消息ID作为数据库主键或唯一键，在消费之前先做插入操作，成功后再进行消费</li>
<li>将最近一段时间消费过的消息ID缓存起来，查询是否已经被消费</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[开源安全框架 - Shiro]]></title>
        <id>https://angus-liu.cn/post/kai-yuan-an-quan-kuang-jia-shiro/</id>
        <link href="https://angus-liu.cn/post/kai-yuan-an-quan-kuang-jia-shiro/">
        </link>
        <updated>2020-09-10T02:24:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="shiro">Shiro</h1>
<blockquote>
<p><a href="http://shiro.apache.org/index.html">Apache Shiro</a></p>
</blockquote>
<h2 id="apche-shiro-简介"># Apche Shiro 简介</h2>
<blockquote>
<p><a href="http://shiro.apache.org/introduction.html#introduction-to-apache-shiro">Introduction to Apache Shiro</a></p>
</blockquote>
<h3 id="apche-shiro-是什么">Apche Shiro 是什么？</h3>
<p>Apache Shiro 是一个功能强大且灵活的开源安全框架，它可以清晰地处理身份验证、授权、企业会话管理，以及加密。</p>
<p>Apache Shiro 的首要目标是易于使用和理解。安全机制的实现有时可能非常复杂，甚至会让人觉得痛苦，但并非必须如此。框架应该尽可能地掩盖复杂性，并提供简洁直观的 API，以简化开发人员为确保应用程序的安全所做的工作。</p>
<p>以下是一些借助 Apache Shiro 可以做的事情：</p>
<ul>
<li>
<p>对用户进行身份验证</p>
</li>
<li>
<p>对用户执行访问控制，例如：</p>
<ul>
<li>确定是否为用户分配了某个安全角色</li>
<li>确定是否允许用户执行某些操作</li>
</ul>
</li>
<li>
<p>可以在任何环境中使用 Session API，即使没有 Web 或 EJB容器</p>
</li>
<li>
<p>在身份验证、访问控制或会话生命周期内对事件作出反应</p>
</li>
<li>
<p>聚合一个或多个用户安全数据数据源，并将其呈现为单个复合用户“视图”</p>
</li>
<li>
<p>启用单点登录(SSO)功能</p>
</li>
<li>
<p>启用“记住我（Remember Me）”服务，无须登录便可与用户建立关联</p>
<p>……</p>
<p>更重要的是，以上全部都集成在一个内聚且易于使用的 API 中。</p>
</li>
</ul>
<p>Shiro 尝试为所有应用程序环境实现这些目标——从最简单的命令行应用程序到最大的企业应用程序，并且不强制依赖其他第三方框架，容器或应用程序服务器。当然，该项目旨在尽可能地集成到这些环境中，但它也可以在其他任何环境中开箱即用。</p>
<h3 id="apache-shiro-特性">Apache Shiro 特性</h3>
<p>Apache Shiro 是一个具有许多功能的综合应用程序安全框架。下图显示了 Shiro 的主要关注点，本参考手册将以类似方式进行组织：</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/Angus-Liu/mtbox/raw/master/docs/shiro/assets/ShiroFeatures.png" alt="img" loading="lazy"></figure>
<p>Shiro 针对的是 Shiro 开发团队所称的“应用程序安全的四大基石”——身份验证，授权，会话管理和加密：</p>
<ul>
<li><strong>身份验证（Authentication）：</strong> 有时称之为“登录”，该行为用以证明用户是他们所说的那个人。</li>
<li><strong>授权（Authorization）：</strong> 访问控制的过程，即确定“谁”可以访问“什么”。</li>
<li><strong>会话管理（Session Management）：</strong> 管理特定于用户的会话，即使不在 Web 或 EJB 应用程序中。</li>
<li><strong>加密（Cryptography）：</strong> 使用加密算法保证数据安全，同时要易于使用。</li>
</ul>
<p>在不同的应用程序环境中，还有其他特性支持和加强这些关注点，特别是：</p>
<ul>
<li>Web 支持：Shiro 的 Web 支持 API 可帮助 Web 应用程序轻松地获取保护。</li>
<li>缓存：缓存是 Apache Shiro API 中的一级公民，可确保安全操作保持快速和高效。</li>
<li>并发：Apache Shiro 的并发特性使其支持多线程应用程序。</li>
<li>测试：对测试的支持，可以帮助您编写单元和集成测试，确保你的代码如预期的那样得到保护。</li>
<li>“Run As”：允许用户假定为其他用户身份（如果允许）的功能，有时在管理场景中很有用。</li>
<li>“记住我（Remember Me）”：记住用户在不同会话中的身份，因此用户只需在强制登录时才进行登录。</li>
</ul>
<h2 id="apache-shiro-架构"># Apache Shiro 架构</h2>
<blockquote>
<p><a href="http://shiro.apache.org/architecture.html#apache-shiro-architecture">Apache Shiro Architecture</a></p>
</blockquote>
<p>Apache Shiro 的设计目标是通过直观性和易用性来简化应用程序安全性的实现。在某人（或某物）与应用程序交互的上下文中，Shiro 的核心设计模拟了大多数人对应用程序安全性的看法。</p>
<p>软件应用通常基于用户故事设计。也就是说，你通常会根据用户将要（或应该）怎么与软件交互的方式设计用户界面或服务API。例如，你可能会说，“与我的应用程序交互时，如果用户已经登陆，就会向他们显示一个按钮，他们可以单击该按钮查看其帐户信息。如果没有登录，则显示一个注册按钮。“</p>
<p>这个例子表明，编写应用程序主要是为了满足用户的需求。即使当前正与软件进行交互的“用户”不是人类，而是另一个软件系统，你仍然需要编写代码反映其行为。</p>
<p>Shiro 在自己的设计中体现了这些概念。通过搭配对软件开发人员来说已经很直观的内容，Apache Shiro 在几乎任何应用程序中都能保持直观和易于使用。</p>
<h3 id="高层概述">高层概述</h3>
<p>在最高层次的概念上，Shiro 的架构有 3 个主要概念：<code>Subject</code>、<code>SecurityManager</code> 和 <code>Realms</code>。下图是这些组件如何交互的高级概述，我们将介绍其中的每个概念：</p>
<figure data-type="image" tabindex="2"><img src="https://github.com/Angus-Liu/mtbox/raw/master/docs/shiro/assets/ShiroBasicArchitecture.png" alt="img" loading="lazy"></figure>
<ul>
<li>
<p><strong>Subject</strong>：正如我们在<a href="http://shiro.apache.org/tutorial.html">教程</a>中提到的，<code>Subject</code> 本质上是当前正在进行操作的用户特定于安全性的“视图”。虽然“用户”这个词通常意味着一个人，但 <code>Subject</code> 可以是一个人，也可以代表第三方服务、守护进程帐户，cron作业或任何类似的东西 —— 基本上是当前与软件交互的任何东西。</p>
<p><code>Subject</code> 实例都被绑定（并且需要）到一个 <code>SecurityManager</code> 上。当你与一个 <code>Subject</code> 进行交互时，这些交互将转换为与 <code>SecurityManager</code> 特定于主题的交互。</p>
</li>
<li>
<p><strong>SecurityManager</strong>：<code>SecurityManager</code> 是 Shiro 架构的核心，它充当着“伞形”对象的角色，以协调其内部安全组件，共同构成一个对象图。值得注意的是，一旦为应用程序配置了 <code>SecurityManager</code> 及其内部对象图，通常就不需要再管它了，应用程序开发人员几乎将所有时间花在 <code>Subject</code> API上。</p>
<p>稍后我们将详细讨论 <code>SecurityManager</code>，但重要的是要意识到，当你与 <code>Subject</code> 交互时，实际上是 <code>SecurityManager</code> 在幕后为 <code>Subject</code> 承担了所有繁重的工作。这反映在上面的基本流程图中。</p>
</li>
<li>
<p><strong>Realms</strong>：Realm 充当 Shiro 与应用程序安全数据之间的“桥梁”或“连接器”。当需要与与安全相关的数据（如用户帐户）进行实际交互以执行身份验证（登录）和授权（访问控制）时，Shiro 会从一个或多个为应用程序配置的 Realm 中查找这些内容。</p>
<p>从这个意义上讲，Realm 本质上是一个特定于安全性的 <a href="https://en.wikipedia.org/wiki/Data_access_object">DAO</a>：它封装了数据源的连接细节，并根据需要将相关数据提供给 Shiro。配置Shiro时，必须至少指定一个 Realm 用于身份验证和（或）授权。<code>SecurityManager</code> 可以配置多个 Realm，且至少需要一个。</p>
<p>Shiro 提供了开箱即用的 Realm，可以连接到许多安全数据源（也称目录），如 LDAP、关系数据库（JDBC）、文本配置源（如INI和属性文件）等。如果缺省 Realm 不满足你的需求，你可以插入自己的 Realm 实现来表示自定义数据源。</p>
<p>与其他内部组件一样，Shiro <code>SecurityManager</code> 管理着如何使用 Realm 来获取将被表示为 <code>Subject</code> 实例的安全数据和标识数据。</p>
</li>
</ul>
<h3 id="详细架构">详细架构</h3>
<p>下图展示了 Shiro 的核心架构概念，并对每个概念进行了简短的总结:</p>
<figure data-type="image" tabindex="3"><img src="https://github.com/Angus-Liu/mtbox/raw/master/docs/shiro/assets/ShiroArchitecture.png" alt="img" loading="lazy"></figure>
<ul>
<li><strong>Subject</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/subject/Subject.html">org.apache.shiro.subject.Subject</a>）<br>
当前与软件交互的实体（用户，第三方服务，cron 作业等）特定于安全性的“视图”。</li>
<li><strong>SecurityManager</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/mgt/SecurityManager.html">org.apache.shiro.mgt.SecurityManager</a>）<br>
如上所述，<code>SecurityManager</code> 是 Shiro 架构的核心。它主要是一个“伞形”对象，协调其托管组件，以确保它们一起平稳运行。它还管理每个应用程序用户的 Shiro 视图，因此它知道如何对每个用户执行安全操作。</li>
<li><strong>Authenticator</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/Authenticator.html">org.apache.shiro.authc.Authenticator</a>）<br>
<code>Authenticator</code> 是负责执行和响应用户身份验证（登录）尝试的组件。当用户尝试登录时，将由<code>Authenticator</code> 执行该逻辑。<code>Authenticator</code> 知道如何与存储相关用户/帐户信息的一个或多个 Realm 进行协调。从这些 Realm 获得的数据将用于验证用户的身份，以确保用户确实是他们所说的那个人。
<ul>
<li><strong>Authentication Strategy</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/AuthenticationStrategy.html">org.apache.shiro.authc.pam.AuthenticationStrategy</a>）<br>
如果配置了多个 Realm，<code>AuthenticationStrategy</code> 将对 Realm 进行协调以确定身份验证成功或失败的条件（例如，如果一个 Realm 验证成功但其他 Realm 失败，这次尝试是否成功？还是说需要所有 Realm 都验证成功？抑或是只需要第一个 Realm 验证成功就可以？）。</li>
</ul>
</li>
<li><strong>Authorizer</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authz/Authorizer.html">org.apache.shiro.authz.Authorizer</a>）<br>
<code>Authorizer</code> 是负责确定应用程序中用户访问控制的组件。它是一种最终决定用户是否被允许做某事的机制。与 <code>Authenticator</code> 类似，<code>Authorizer</code> 也知道如何协调多个后端数据源，以访问角色和权限信息。<code>Authorizer</code> 使用这些信息来确定是否允许用户执行特定的操作。</li>
<li><strong>SessionManager</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/session/mgt/SessionManager.html">org.apache.shiro.session.mgt.SessionManager</a>）<br>
<code>SessionManager</code> 知道如何创建和管理用户 <code>Session</code> 生命周期，为所有环境中的用户提供健壮的会话体验。这是安全框架领域的一个独特特性——即使没有可用的 Web、Servlet 或 EJB 容器，Shiro 也能够在任何环境中管理用户 Sessions。默认情况下，Shiro 将使用现有的会话机制（例如 Servlet 容器），但若是没有，比如在独立应用程序或非 Web 环境中，它将使用其内置的企业会话管理提供相同的编程过程。<code>SessionDAO</code> 的存在允许任何数据源用于持久会话。
<ul>
<li><strong>SessionDAO</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/session/mgt/eis/SessionDAO.html">org.apache.shiro.session.mgt.eis.SessionDAO</a>）<br>
<code>SessionDAO</code> 代表 <code>SessionManager</code> 执行 <code>Session</code> 持久性（CRUD）操作。这允许将任何数据存储插入会话管理基础结构。</li>
</ul>
</li>
<li><strong>CacheManager</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/cache/CacheManager.html">org.apache.shiro.cache.CacheManager</a>）<br>
<code>CacheManager</code> 负责创建和管理其他 <code>Shiro</code> 组件使用的 <code>Cache</code> 实例生命周期。由于 Shiro 可以访问许多后端数据源以进行身份验证，授权和会话管理，因此缓存一直是框架中极其重要的架构特性，其可以在使用这些数据源时提高性能。任何现代开源的或企业缓存产品都可以插入 Shiro，以提供快速有效的用户体验。</li>
<li><strong>Cryptography</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/crypto/package-summary.html">org.apache.shiro.crypto.*</a>）<br>
加密机制是企业安全框架的自然补充。Shiro 的 <code>crypto</code> 软件包包含了易于使用和理解的密码、哈希（亦称摘要）和不同编解码器的实现。该软件包中的所有类都经过精心设计，易于使用且易于理解。使用 Java 原生加密支持的人都知道，它就像种很难被驯服的动物。Shiro 的 <code>crypto</code> API 简化了复杂的 Java 机制，使普通人易于使用。</li>
<li><strong>Realms</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/realm/Realm.html">org.apache.shiro.realm.Realm</a>）<br>
如上所述，Realm 充当 Shiro 与应用程序安全数据之间的“桥接”或“连接器”。当需要与安全相关的数据（如用户帐户）进行实际交互以执行身份验证（登录）和授权（访问控制）时，Shiro 会从一个或多个为应用程序配置的 Realm 中查找这些内容。你可以根据需要配置任意多个 Realm（通常每个数据源一个），Shiro 将根据身份验证和授权的需要与它们进行协调。</li>
</ul>
<h3 id="securitymanager">SecurityManager</h3>
<p>由于 Shiro 的API鼓励以 <code>Subject</code> 为中心的编程方法，所以大多数应用程序开发人员很少直接与<code>SecurityManager</code> 交互（框架开发人员有时可能会发现它很有用）。即便如此，了解 <code>SecurityManager</code> 功能仍然很重要，尤其是在为应用程序配置 <code>SecurityManager</code> 时。</p>
<h3 id="设计">设计</h3>
<p>如前所述，应用程序的 <code>SecurityManager</code> 负责执行安全操作并管理所有应用程序用户的状态。在 Shiro 的默认 <code>SecurityManager</code> 实现中，这包括：</p>
<ul>
<li>Authentication（认证）</li>
<li>Authorization（授权）</li>
<li>Session Management（会话管理）</li>
<li>Cache Management（缓存管理）</li>
<li><a href="http://shiro.apache.org/realm.html">Realm</a> coordination（Realm 协调）</li>
<li>Event propagation（事件传播）</li>
<li>“Remember Me” Services（“记住我”服务）</li>
<li>Subject creation（Subject 创建）</li>
<li>Logout and more （登出等）</li>
</ul>
<p>这只是尝试在单个组件中管理这么多的功能。如果将所有内容集中到一个实现类中，那么要使这些东西具有灵活性和可定制性将非常困难。</p>
<p>为了简化配置并实现灵活的配置和可插拔性，Shiro 的实现都是高度模块化的设计——模块化程度如此之高，以至于 SecurityManager 实现(及其类层次结构)根本做不了什么。相反，这些 <code>SecurityManager</code> 实现主要充当轻量级“容器”组件，将几乎将所有行为委托给嵌套和包装组件。这种“包装”设计反映在上面的详细架构图中。</p>
<p>当组件实际执行逻辑时，<code>SecurityManager</code> 实现知道如何以及何时协调组件以获得正确的行为。</p>
<p><code>SecurityManager</code> 的实现和组件也兼容 JavaBean，它允许你(或配置机制)通过标准 JavaBean 访问器和修改器方法（get*/set*）轻松定制可插入组件。这意味着 Shiro 的体系结构模块化可以为自定义行为转化为非常容易的配置。</p>
<blockquote>
<p>易于配置：因为 JavaBean 的兼容性，通过任何支持 JavaBean 样式配置的机制，例如 <a href="http://shiro.apache.org/spring.html">Spring</a>，Guice，JBoss等，都可以很容易地使用自定义组件配置 <code>SecurityManager</code>。</p>
</blockquote>
<h2 id="apache-shiro-术语"># Apache Shiro 术语</h2>
<blockquote>
<p><a href="http://shiro.apache.org/terminology.html#apache-shiro-terminology">Apache Shiro Terminology</a></p>
</blockquote>
<h2 id="10-分钟教程"># 10 分钟教程</h2>
<blockquote>
<p><a href="http://shiro.apache.org/10-minute-tutorial.html">10 Minute Tutorial on Apache Shiro</a></p>
</blockquote>
<h3 id="介绍">介绍</h3>
<p>欢迎来到 Apache Shiro 的 10 分钟教程！</p>
<p>通过这个简单快速的教程，你可以完全理解开发人员如何在应用程序中使用 Shiro。你应该可以在10分钟内完成。</p>
<h3 id="概述">概述</h3>
<p>Apache Shiro 是什么？</p>
<p>Apache Shiro 是一个功能强大且易于使用的 Java 安全框架，它为开发人员提供了一种直观且全面的身份验证、授权、加密和会话管理解决方案。</p>
<p>实际上，它实现了管理应用程序安全性的所有方面，同时尽可能不碍事。它建立在良好的接口驱动设计和 OO 原则之上，在你能够想象的任何地方都支持自定义行为。此外，对于一切它都有合理的默认值，是应用程序安全性所能做到的最大程度的“不干涉（hands off）”。至少这是我们所追求的。</p>
<p>Apache Shiro 可以做什么？</p>
<p>太多了🙂。但我们不想让 QuickStart 变得臃肿。如果想了解它能为你做些什么，请查看<a href="http://shiro.apache.org/features.html">功能</a>页面。此外，如果对我们是如何开始的以及我们为什么存在感兴趣，请参阅 <a href="http://shiro.apache.org/what-is-shiro.html">Shiro 的历史和使命</a>页面。</p>
<p>好的。现在让我们开始吧!</p>
<blockquote>
<p>注意：Shiro 可以在任何环境中运行，从最简单的命令行应用程序到最大的企业级 web 和集群应用程序，但在 QuickStart 中，我们将在一个简单的“main”方法中完成这个最简单的示例，这样你就可以对 API 有所了解。</p>
</blockquote>
<h3 id="下载">下载</h3>
<ol>
<li>
<p>确保安装了 JDK 1.6+ 和 Maven 3.0.3+。</p>
</li>
<li>
<p>从<a href="http://shiro.apache.org/download.html">下载</a>页面下载最新的“源代码分发（Source Code Distribution）” 。本示例中使用的是 1.4.0 分发版。</p>
</li>
<li>
<p>解压：</p>
<pre><code class="language-shell">$ unzip shiro-root-1.4.0-source-release.zip
</code></pre>
</li>
<li>
<p>进入 quickstart 目录：</p>
<pre><code class="language-shell">$ cd shiro-root-1.4.0/samples/quickstart
</code></pre>
</li>
<li>
<p>运行 QuickStart：</p>
<pre><code class="language-shell">$ mvn compile exec:java
</code></pre>
</li>
</ol>
<p>这个目标只会打印出一些日志消息，让你知道发生了什么，然后就会退出。在阅读本文时，可以随时查看下面的代码 <code>samples/quickstart/src/main/java/Quickstart.java</code>。对它进行修改并根据需要运行上述的  <code>mvn compile exec:java</code> 命令。</p>
<h3 id="quickstartjava">Quickstart.java</h3>
<p>上面引用的 <code>Quickstart.java</code> 文件包含了使你熟悉 API 的所有代码。现在让我们把它分成几块，这样你就可以很容易地理解发生了什么。</p>
<p>在几乎所有的环境中，你都可以通过以下调用方式获取当前正在执行的用户：</p>
<pre><code class="language-java">Subject currentUser = SecurityUtils.getSubject();
</code></pre>
<p>通过 <a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/SecurityUtils.html"><code>SecurityUtils</code></a>.<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/SecurityUtils.html#getSubject--"><code>getSubject()</code></a> 方法，我们可以获得当前正在执行的<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/subject/Subject.html"><code>Subject</code></a>。“Subject”仅仅是应用程序用户特定于安全性的“视图”。实际上，我们本想把它称为“User”，因为这“很有意义”，但是我们决定不这么做：太多的应用程序现有的 API 中已经有了自己的 User 类或框架，我们不想与它们发生冲突。而且，在安全领域，<code>Subject</code> 实际上是公认的术语。好了，继续……</p>
<p>独立应用程序中的 <code>getSubject()</code> 调用可能返回一个应用程序中指定位置的用户数据对应的 <code>Subject</code>，而在服务器环境（例如 web 应用程序）中， <code>Subject</code> 则基于与当前线程或传入请求相关联的用户数据来获取。</p>
<p>既然有了 <code>Subject</code>，那能用它来做什么？</p>
<p>如果你希望在当前会话期间向应用程序用户提供内容，你可以获取其会话：</p>
<pre><code class="language-java">Session session = currentUser.getSession();
session.setAttribute( &quot;someKey&quot;, &quot;aValue&quot; );
</code></pre>
<p><code>Session</code> 是特定于 Shiro 的实例，它不仅提供了常规 HttpSession 所提供的大部分内容，而且还有一些额外的好处和一个<strong>很大的</strong>区别：它不需要HTTP环境！</p>
<p>如果在 Web 应用程序内部部署，默认情况下 <code>Session</code> 将基于 <code>HttpSession</code>。但是，在非 Web 环境中，比如这个简单的 Quickstart，Shiro 默认会自动使用其自带的企业会话管理。这意味着无论部署环境如何，你都可以在任何层中的应用程序中使用相同的API。这打开了一个全新的应用程序世界，任何需要会话的应用程序都不需要被强制使用 <code>HttpSession</code> 或 EJB Stateful Session Bean。而且，任何客户端技术现在都可以共享会话数据。</p>
<p>现在你可以获得一个 <code>Subject</code> 和它们的 <code>Session</code>。那么真正有用的东西呢，比如检查是否允许它们执行某些操作，或者检查角色和权限?</p>
<p>我们只能对已知用户进行检查。<code>Subject</code> 上面的实例代表当前用户，但“谁”是当前用户？目前，他们是匿名的——也就是说，至少需要他们登录一次。所以，让我们这样做：</p>
<pre><code class="language-java">if ( !currentUser.isAuthenticated() ) {
    //collect user principals and credentials in a gui specific manner
    //such as username/password html form, X509 certificate, OpenID, etc.
    //We'll use the username/password example here since it is the most common.
    //(do you know what movie this is from? ;)
    UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);
    //this is all you have to do to support 'remember me' (no config - built in!):
    token.setRememberMe(true);
    currentUser.login(token);
}
</code></pre>
<p>就是这样！再简单不过了。</p>
<p>但如果他们的登录尝试失败了怎们办？通过捕捉各种特定的异常，可以告诉你到底发生了什么，这允许你进行相应的处理和反应：</p>
<pre><code class="language-java">try {
    currentUser.login( token );
    //if no exception, that's it, we're done!
} catch ( UnknownAccountException uae ) {
    //username wasn't in the system, show them an error message?
} catch ( IncorrectCredentialsException ice ) {
    //password didn't match, try again?
} catch ( LockedAccountException lae ) {
    //account for that username is locked - can't login.  Show them a message?
}
    ... more types exceptions to check if you want ...
} catch ( AuthenticationException ae ) {
    //unexpected condition - error?
}
</code></pre>
<p>你可以检查许多不同类型的异常，或者针对 Shiro 可能无法解释的自定义条件抛出你自己的异常。有关更多信息，请参阅 <a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/AuthenticationException.html">AuthenticationException JavaDoc</a>。</p>
<blockquote>
<p>提示：安全的最佳实践是向用户提供通用的登录失败消息，你应该不想帮助攻击者试图闯入你的系统吧。</p>
</blockquote>
<p>好的，到现在为止，我们已经登录了用户。那还能做什么？</p>
<p>可以让我们看看他们是谁：</p>
<pre><code class="language-java">//print their identifying principal (in this case, a username): 
log.info( &quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot; );
</code></pre>
<p>可以测试他们是否具有特定的角色：</p>
<pre><code class="language-java">if ( currentUser.hasRole( &quot;schwartz&quot; ) ) {
    log.info(&quot;May the Schwartz be with you!&quot; );
} else {
    log.info( &quot;Hello, mere mortal.&quot; );
}
</code></pre>
<p>还可以看看他们是否有权对某种类型的实体进行操作：</p>
<pre><code class="language-java">if ( currentUser.isPermitted( &quot;lightsaber:weild&quot; ) ) {
    log.info(&quot;You may use a lightsaber ring.  Use it wisely.&quot;);
} else {
    log.info(&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;);
}
</code></pre>
<p>此外，我们可以执行一个极其强大的“实例级”权限检查——查看用户是否能够访问该类型的特定实例：</p>
<pre><code class="language-java">if ( currentUser.isPermitted( &quot;winnebago:drive:eagle5&quot; ) ) {
    log.info(&quot;You are permitted to 'drive' the 'winnebago' with license plate (id) 'eagle5'.  &quot; +
                &quot;Here are the keys - have fun!&quot;);
} else {
    log.info(&quot;Sorry, you aren't allowed to drive the 'eagle5' winnebago!&quot;);
}
</code></pre>
<p>小菜一碟，是吧？</p>
<p>最后，当用户结束使用应用程序时，他们可以进行注销：</p>
<pre><code class="language-java">currentUser.logout(); //removes all identifying information and invalidates their session too.
</code></pre>
<p>这就是在应用程序开发人员级别使用的 Apache Shiro 的核心内容。虽然有一些相当复杂的东西在幕后进行，使得这个工作如此优雅，但实际上就是这些。</p>
<p>你心中可能仍有疑惑，“到底是谁负责在登录期间获取用户数据（用户名和密码，角色和权限等），又是谁在运行时实际地去执行这些安全检查？”这些，通过实现 Shiro 所称的 <a href="http://shiro.apache.org/realm.html">Realm</a> 并将其插入 Shiro 的配置中，就可以做到。</p>
<p>但是，如何配置 <a href="http://shiro.apache.org/realm.html">Realm</a> 在很大程度上取决于你的运行时环境。例如，运行独立应用程序，或是基于 Web 的应用程序，或是基于 Spring 或 JEE 容器的应用程序，抑或是它们的组合。不过这种类型的配置超出了本文的范围，QuickStart 的目的是让你熟悉 API 和 Shiro 的概念。</p>
<p>当准备好了解更多详细信息时，你肯定希望阅读<a href="http://shiro.apache.org/java-authentication-guide.html">身份验证指南</a>和<a href="http://shiro.apache.org/java-authorization-guide.html">授权指南</a>。然后可以转到其他<a href="http://shiro.apache.org/documentation.html">文档</a>，特别是<a href="http://shiro.apache.org/reference.html">参考手册</a>，可以回答你的任何其他问题。或许你也想加入用户<a href="http://shiro.apache.org/mailing-lists.html">邮件列表</a>——你会发现我们有一个很好的社区，人们愿意尽可能地提供帮助。</p>
<p>感谢你的关注。希望你能喜欢上 Apache Shiro！</p>
<h2 id="将-apache-shiro-集成到-springboot-应用程序中"># 将 Apache Shiro 集成到 SpringBoot 应用程序中</h2>
<blockquote>
<p><a href="https://shiro.apache.org/spring-boot.html">Integrating Apache Shiro into Spring-Boot Applications</a></p>
</blockquote>
<p>Shiro 的 SpringBoot 集成方式是将 Shiro 集成到基于 Spring 的应用程序中的最简单方法，对于更一般的 Spring 框架集成，可以采用<a href="https://shiro.apache.org/spring-framework.html">注解</a>或 <a href="https://shiro.apache.org/spring-xml.html">XML</a>。</p>
<h3 id="独立应用程序">独立应用程序</h3>
<p>在你的应用程序类路径中包含 Shiro Spring starter 依赖项（推荐使用 Apache Maven 或 Gradle 等工具来管理）。</p>
<pre><code>// Apache Maven
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.4.1-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;

// Gradle
compile 'org.apache.shiro:shiro-spring-boot-starter:1.4.1-SNAPSHOT'
</code></pre>
<p>剩下的唯一事情是配置一个 <a href="https://shiro.apache.org/realm.html">Realm</a>：</p>
<pre><code class="language-java">@Bean
public Realm realm() {
  ...
}
</code></pre>
<p>设置 Shiro 最简单的方法是使 SecurityUtils.* 方法在所有情况下都能工作，也就是让 <code>SecurityManager</code> bean成为一个静态单例。请勿在 Web 应用程序中执行此操作——请参阅下面的 <a href="https://shiro.apache.org/spring-boot.html#Spring-WebApplications">Web 应用程序</a>部分。</p>
<pre><code class="language-java">@Autowired
private SecurityManager securityManager;
    
 @PostConstruct
 private void initStaticSecurityManager() {
     SecurityUtils.setSecurityManager(securityManager);
 }
</code></pre>
<p>就是这样，现在你可以使用以下方式获取当前 <code>Subject</code> :</p>
<pre><code class="language-java">SecurityUtils.getSubject();
</code></pre>
<p>您可以在 <a href="https://github.com/apache/shiro/tree/master/samples/spring-boot">Github 样例</a>中看到完整的示例。</p>
<h3 id="web-应用程序">Web 应用程序</h3>
<p>Shiro 对 Spring Web 应用程序提供了一流的支持。在 Web 应用程序中，所有可通过 Shiro 访问的 Web 请求都必须通过一个主 Shiro 过滤器。这个过滤器本身非常强大，它允许基于任何 URL 路径表达式执行临时自定义过滤器链。</p>
<p>首先，在你的应用程序类路径中包含 Shiro Spring web starter 依赖项（推荐使用Apache Maven 或 Gradle 之类的工具来管理）。</p>
<pre><code>// Apache Maven
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-spring-boot-web-starter&lt;/artifactId&gt;
    &lt;version&gt;1.4.1-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;

// Gradle
compile 'org.apache.shiro:shiro-spring-boot-web-starter:1.4.1-SNAPSHOT'
</code></pre>
<p>提供Realm实现：</p>
<pre><code class="language-java">@Bean
public Realm realm() {
  ...
}
</code></pre>
<p>最后是 <code>ShiroFilterChainDefinition</code>，它将把任何特定于应用程序的路径映射到给定的过滤器，以便允许不同路径进行不同级别的访问。</p>
<pre><code class="language-java">@Bean
public ShiroFilterChainDefinition shiroFilterChainDefinition() {
    DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition();
    
    // logged in users with the 'admin' role
    chainDefinition.addPathDefinition(&quot;/admin/**&quot;, &quot;authc, roles[admin]&quot;);
    
    // logged in users with the 'document:read' permission
    chainDefinition.addPathDefinition(&quot;/docs/**&quot;, &quot;authc, perms[document:read]&quot;);
    
    // all other paths require a logged in user
    chainDefinition.addPathDefinition(&quot;/**&quot;, &quot;authc&quot;);
    return chainDefinition;
}
</code></pre>
<p>如果你使用的是 Shiro 的注解，请参阅下面的<a href="https://shiro.apache.org/spring-boot.html#Spring-annotations-web">注解</a>部分。</p>
<p>您可以在 <a href="https://github.com/apache/shiro/tree/master/samples/spring-boot-web">Github 样例</a>中看到完整的示例。</p>
<h3 id="启用-shiro-注解">启用 Shiro 注解</h3>
<p>在独立应用程序和 Web 应用程序中，你可能需要使用 Shiro 的注解进行安全校验（例如 <code>@RequiresRoles</code>、<code>@RequiresPermissions</code> 等），在上面列出的启动方法中，这些注解都会自动启用。</p>
<p>只需对你的方法进行注解，就可以使用它们：</p>
<pre><code class="language-java">@RequiresPermissions(&quot;document:read&quot;)
public void readDocument() {
    ...
}
</code></pre>
<p><strong>注解和 Web 应用程序</strong></p>
<p>Shiro 的注解完全支持在 <code>@Controller</code> 类中使用，例如：</p>
<pre><code class="language-java">@Controller
public class AccountInfoController {

    @RequiresRoles(&quot;admin&quot;)
    @RequestMapping(&quot;/admin/config&quot;)
    public String adminConfig(Model model) {
        return &quot;view&quot;;
    }
}
</code></pre>
<p>为此， <code>ShiroFilterChainDefinition</code> bean 中至少需要有一个定义，要么将所有路径配置为可通过 anno（匿名）过滤器访问，要么设置一个过滤器处于 permissive（许可）模式，例如：authcBasic[permissive]。</p>
<pre><code class="language-java">@Bean
public ShiroFilterChainDefinition shiroFilterChainDefinition() {
    DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition();
    chainDefinition.addPathDefinition(&quot;/**&quot;, &quot;anon&quot;); // all paths are managed via annotations
    
    // or allow basic authentication, but NOT require it.
    // chainDefinition.addPathDefinition(&quot;/**&quot;, &quot;authcBasic[permissive]&quot;); 
    return chainDefinition;
}
</code></pre>
<h3 id="缓存">缓存</h3>
<p>启用缓存就像提供 <a href="http://shiro.apache.org/caching.html">CacheManager</a> bean 一样简单：</p>
<pre><code class="language-java">@Bean
protected CacheManager cacheManager() {
    return new MemoryConstrainedCacheManager();
}
</code></pre>
<h3 id="配置属性">配置属性</h3>
<table>
<thead>
<tr>
<th style="text-align:left">键</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">shiro.enabled</td>
<td style="text-align:left"><code>true</code></td>
<td style="text-align:left">启用 Shiro 的 Spring 模块</td>
</tr>
<tr>
<td style="text-align:left">shiro.web.enabled</td>
<td style="text-align:left"><code>true</code></td>
<td style="text-align:left">启用 Shiro 的 Spring Web 模块</td>
</tr>
<tr>
<td style="text-align:left">shiro.annotations.enabled</td>
<td style="text-align:left"><code>true</code></td>
<td style="text-align:left">为 Shiro 的注解启用 Spring 支持</td>
</tr>
<tr>
<td style="text-align:left">shiro.sessionManager.deleteInvalidSessions</td>
<td style="text-align:left"><code>true</code></td>
<td style="text-align:left">从会话存储中删除无效会话</td>
</tr>
<tr>
<td style="text-align:left">shiro.sessionManager.sessionIdCookieEnabled</td>
<td style="text-align:left"><code>true</code></td>
<td style="text-align:left">为 cookie 启用 session ID，以进行会话跟踪</td>
</tr>
<tr>
<td style="text-align:left">shiro.sessionManager.sessionIdUrlRewritingEnabled</td>
<td style="text-align:left"><code>true</code></td>
<td style="text-align:left">启用 sessionURL 重写支持</td>
</tr>
<tr>
<td style="text-align:left">shiro.userNativeSessionManager</td>
<td style="text-align:left"><code>false</code></td>
<td style="text-align:left">如果启用，Shiro 将管理 HTTP session 而不是容器</td>
</tr>
<tr>
<td style="text-align:left">shiro.sessionManager.cookie.name</td>
<td style="text-align:left"><code>JSESSIONID</code></td>
<td style="text-align:left">session cookie 名称</td>
</tr>
<tr>
<td style="text-align:left">shiro.sessionManager.cookie.maxAge</td>
<td style="text-align:left"><code>-1</code></td>
<td style="text-align:left">session cookie 最大生存期</td>
</tr>
<tr>
<td style="text-align:left">shiro.sessionManager.cookie.domain</td>
<td style="text-align:left"><code>null</code></td>
<td style="text-align:left">session cookie 域</td>
</tr>
<tr>
<td style="text-align:left">shiro.sessionManager.cookie.path<code>|</code>null`</td>
<td style="text-align:left">session cookie 路径</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">shiro.sessionManager.cookie.secure</td>
<td style="text-align:left"><code>false</code></td>
<td style="text-align:left">session cookie 安全标志</td>
</tr>
<tr>
<td style="text-align:left">shiro.rememberMeManager.cookie.name</td>
<td style="text-align:left"><code>rememberMe</code></td>
<td style="text-align:left">RememberMe  cookie 名称</td>
</tr>
<tr>
<td style="text-align:left">shiro.rememberMeManager.cookie.maxAge</td>
<td style="text-align:left">one year</td>
<td style="text-align:left">RememberMe cookie 最大生存期</td>
</tr>
<tr>
<td style="text-align:left">shiro.rememberMeManager.cookie.domain</td>
<td style="text-align:left"><code>null</code></td>
<td style="text-align:left">RememberMe cookie域名</td>
</tr>
<tr>
<td style="text-align:left">shiro.rememberMeManager.cookie.path</td>
<td style="text-align:left"><code>null</code></td>
<td style="text-align:left">RememberMe cookie路径</td>
</tr>
<tr>
<td style="text-align:left">shiro.rememberMeManager.cookie.secure</td>
<td style="text-align:left"><code>false</code></td>
<td style="text-align:left">RememberMe cookie安全标志</td>
</tr>
<tr>
<td style="text-align:left">shiro.loginUrl</td>
<td style="text-align:left"><code>/login.jsp</code></td>
<td style="text-align:left">未经身份验证的用户重定向到登录页面时使用的 Login URL</td>
</tr>
<tr>
<td style="text-align:left">shiro.successUrl</td>
<td style="text-align:left"><code>/</code></td>
<td style="text-align:left">用户登录后的默认页面（如果在当前会话中无法找到替代页面）</td>
</tr>
<tr>
<td style="text-align:left">shiro.unauthorizedUrl</td>
<td style="text-align:left"><code>null</code></td>
<td style="text-align:left">未经授权的用户将被重定向到的页面（403 页面）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>免责声明：本文自豪地借助“Google”和“有道”进行翻译，如果发现不通顺，请向他们提 issue 😀</p>
</blockquote>
<h2 id="其他参考资料"># 其他参考资料</h2>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000014479154">Shiro用starter方式优雅整合到SpringBoot中</a></p>
<p><a href="https://juejin.im/post/5ac78b31f265da237411387e">教你 Shiro 整合 SpringBoot，避开各种坑</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重构剑法之山重水复疑无路]]></title>
        <id>https://angus-liu.cn/post/chong-gou-jian-fa-zhi-shan-chong-shui-fu-yi-wu-lu/</id>
        <link href="https://angus-liu.cn/post/chong-gou-jian-fa-zhi-shan-chong-shui-fu-yi-wu-lu/">
        </link>
        <updated>2020-09-07T10:55:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="重构剑法之山重水复疑无路">重构剑法之山重水复疑无路</h1>
<blockquote>
<p>这真的是一篇正经的技术文章。 —— 鲁迅</p>
</blockquote>
<h2 id="楔子">楔子</h2>
<p>是夜，一轮明月挂在树梢，微风轻拂，掀起淡淡花香。</p>
<p>江边有一艘小船靠岸停下，烛光悠悠。之前吹笛的白衣少年，此刻已起了倦意，合上了眼眸。然而夜晚并不似表面这般平静，一股杀机正从江边小树林中悄悄蔓延出来。定睛一看，一名黑衣男子正朝着少年的方向潜行过来，妄图趁白衣少年不备，就要使出一招吸星大法。</p>
<p>眼见那男子快要得逞，殊不知白衣少年早已用“委托”和“代理”心法，将自己七魄中的灵慧移到了鞘中利剑。还未等男子靠近半分，“咻”的一声，宝剑自行飞出，带着凌冽的剑气直指黑衣男子而去。心中暗道“不好”，黑衣男子旋即放弃进攻，抽身后退。“你在等我？”，刚站稳脚跟，男子的语气中夹带了些许诧异，显然没料到这是少年故意布下的局，局中先前隐匿的白棋一一浮现，杀气四漏。</p>
<p>“不，是在等一个将死之人”，少年睁开了眼睛，收回宝剑。男子闷哼一声，随即不知用了什么奇门遁甲之术，将自己的身形隐去，百般招式接连不断向少年扔来。少年微微皱眉，未见犹豫，便将自身内力放了出来，一道“卫语句”屏障浮现在身体周围，使得黑衣男子一时间无法靠近半丈。未等男子发动下一轮攻击，少年一记“断言”剑法朝前方劈出。男子再无所遁形，身法中的破绽也一一展现，每一击都被少年轻松接下。但看那少年，依旧如先前一般，左手握着一支竹笛背在身后，只用了单单右手应对，下盘纹丝未动，好生潇洒随意。</p>
<p>男子面露难色，知道自己凶多吉少，便横下心以燃烧生命为代价，使出那“杀敌一千自损八百”的秘技，硬生生将自己的内力提高了好几个层次。手中的动作也变得迅猛狠辣起来，上中下三路齐出，妄图打他个措手不及。但看那白衣少年神色坦然并不慌忙，左手“函数式编程”，右手“策略模式”将男子各路套数纷纷化解。末了，少年还不忘喂给男子一剑。这看似简单的一剑，却蕴藏了无穷的内劲，缘是那少年使用“继承”和“封装”，借助“模板方法”将万般武学精华融进了这一招式中。这一剑直中要害，打的男子元神俱灭，卧地不起。</p>
<p>事罢，白衣少年重新点燃了刚才打斗中熄灭的烛火，拂衣而去，留下已无还手能力的男子任他自生自灭。“这，是什么剑法？”，躺在地上的男子呼吸渐失，问了自己在这世上的最后一个问题。“重构”，一声回复从远处悠悠传来，碧波荡漾，岸边已不见之前停靠的小船。</p>
<p>此刻，一轮红日缓缓升起，照的江面熠熠生辉。</p>
<h2 id="序章">序章</h2>
<p>随着对团队项目的理解不断加深，编码也愈发熟练，开发之余便有一些时间去思考项目代码的优化，把自己的一些想法付诸实践。也常常否定昨天的自己，不断进行反思总结，希望探索出更好的设计。</p>
<p>本系列文章便是记录自己从《重构》一书中所学各项技巧在真实项目（以 Kotlin 为编程语言的 Web 后台项目）中的思考和运用。如果其中有一条能给你带来启发，运用在后续的代码编写中，对我来说就是莫大的鼓舞。我非常推荐你阅读《重构》这本书，事不宜迟。</p>
<p>在此非常感谢送给我《重构》这本电子书的引路人 —— 张师傅（公众号：张师傅的博客）</p>
<h3 id="重构定义">重构定义</h3>
<p>关于重构，Martin  Fowler 曾在书中这样说道：</p>
<blockquote>
<p>Refactoring is the process of changing a software system in such a way that it does not alter the external behavior of the code yet improves its internal structure. It is a disciplined way to clean up code that minimizes the chances of introducing bugs. In essence when you refactor you are improving the design of the code after it has been written.</p>
<p>在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。重构是一种经千锤百炼形成的有条不紊的程序整理方法，可以最大限度地减少整理过程中引入错误的几率。本质上说，重构就是在代码写好之后改进它的设计。</p>
</blockquote>
<p>重构既是让设计贯穿代码的整个生命过程：设计、编写、测试、优化、运行、维护、修改和删除。通过不同的技巧，针对代码某些阶段进行优化，实现正反馈机制，延续代码生命周期。</p>
<p>我们所写的代码直接面向的对象主要有三个：当下的自己、计算机和未来的开发者。</p>
<p>对我们自己而言，短时间内为了开发效率或者赶进度，并不强求代码的简洁和扩展性。根据我自身经历，也不推荐在没有一定经验或者方法时就在开发初始夸夸其谈未来或者扩展性。过度设计是新手比较容易掉入的一个大坑，但黑格尔也曾说过“只有那些躺在坑里从不仰望高空的人，才不会再掉进坑里”。我们需要找到一个调节点，平衡这其中的矛盾，那就是重构。</p>
<p>对于计算机，我们只需要利用编码准确描述自己的意图即可。因为各种缘由，我们时常会表述不清或者思考不全，导致计算机的理解与预想情况大相径庭。多数情况下，如果程序本身的逻辑没有问题，通过重构也许会带来一些性能优化，但通常不会改变其外在行为。</p>
<p>未来的开发者可能仍旧是我们自己，也或许是接手代码的人，多数情况下则是代码调用方。此时，重构的意义得以完整彰显。据说保安有灵魂三问：你是谁？从哪来？到哪去？重构对于我们的代码而言，恰是处理这三个问题的执行者。它帮助我们调节代码结构，使代码更具前瞻性和包容性。它帮助未来的开发者理解代码的意图，更清晰的回答这三个问题。</p>
<p>###重构目的</p>
<p>计算机科学相信所有问题都可以通过增加一个间接层来解决，重构中很重要的部分就是对间接层的管理，视情况进行增加或者减少。</p>
<p>重构不是万金油，能打理程序的方方面面，更不是一颗能让人顿悟编程之禅的银弹，但它可以是新冠疫情下的医用口罩，是 75% 的酒精。对于国家这个庞大的系统来说，它们阻止了事态恶化。对于个人，则成了人与人之间和谐相处的桥梁。总体而言，重构大概有这样一些目的和好处：</p>
<ul>
<li>重构可以改进系统设计，让其在崩坏之前重回正轨，使每一行代码物尽其用，提高开发人员的重视程度和规范性，减少技术债。通过重构，封装条件逻辑，将变化进行隔离，对扩展进行开放，减少修改代码带来的副作用。</li>
<li>重构可以提高代码的理解性，降低其阅读难度和修改门槛。此外， 适当借助其中的一些技巧，对已有代码按照自己的理解进行修改和验证，也能帮助我们更快理解不熟悉的系统。</li>
<li>重构还能帮助找到程序漏洞，促使开发人员写出的代码更具鲁棒性。一方面，当调用他人的代码出现问题时，势必要借助重构的一些技巧来梳理代码，揪出问题所在；另一方面，不断对自己的代码进行重构，也能在问题发生前让其无所遁形。</li>
<li>重构能减少后期的开发工作和维护成本。很多时候，重构的受益者就是我们自己，编写的代码还是需要我们亲自维护。根据墨菲定律，我们在匆匆忙忙间写下的代码，总有一天会出其不备产生一个隐藏的漏洞，然后夜半三更被 leader 叫起来改 bug。新增一个 feature 时，也会因为糟糕的设计，使得编码道路险象迭生。稍不注意就会跌到一个隐藏的坑中，尽管这个坑是你挖的，但它不会因为你是主人就放你一马。</li>
<li>最后，重构可以提高开发人员的编程能力。曾子曰：吾日三省吾身，通过不断地反思和总结，勇于否定昨天的自己，亦是我们能力成长的一个重要途径。</li>
</ul>
<h3 id="重构时机">重构时机</h3>
<p>什么时候开始重构呢，一定要掌握相当多的技巧之后才能进行吗？曾经的我一度这么以为，但其实重构的起点非常简单，几乎没有任何门槛。只需要从整理代码开始，给予变量或方法一个合适的名称并将其中拼写错误的单词进行修正，将意图相似的方法移到一起进行管理，把类按照不同层次划分到不同包中，根据 IDE 的提示减少项目中的 Warning，与团队保持一致的编码风格等等。这些都是随手就可以做的事情，花费不了多少时间，也不需要太多技巧。相反，如果我们选择视而不见，总是想着下次再改进，久而久之，代码就会慢慢腐烂，散发出阵阵恶臭，接手的人即使捂着鼻子也不太愿意去修改。</p>
<blockquote>
<p>凡是原本可以做得更好的，也算是懒！ —— 苏格拉底</p>
</blockquote>
<p>美国童子军有这样一条规则：“Leave the campground cleaner than you found it”（离开营地前让它比你到来时更干净）。对于重构来说，亦如此，最好的时机就是当下。重构理应是代码生命过程的一部分，就好比打扫卫生，整理房间是我们生活的一部分，但具体什么时候怎么做，需要靠我们自己去规划，去衡量。值得一提的是，修改并不等于重构，修改有时候是为了性能优化，有时候是响应需求，有时候则是为了妥协。</p>
<p>在着手开始重构之前，先来捋一捋代码的哪些征兆告诉我们项目应该开始重构了：</p>
<ul>
<li>低级错误：变量命名、单词拼写、代码缩进、注释维护等。对这些点的修改也许还算不上重构，但这些却是我们常犯也常忽略的问题。</li>
<li>重复代码：DRY（Don't repeat yourself）和 Rule of three（三次原则）告诉我们，相似的代码出现两次时无关紧要，但出现第三次时就应该开始重构了。事不过三，代码复制短期可以节省开发时间，但长期这么做必然会加剧维护和修改的工作量，也会降低开发者的热情。</li>
<li>职责繁杂：让一个函数或类承担过多职责，是产生 bug 的主要根源。古代道家哲学就告诉我们“大道至简”，对于一个函数或是类来说，同样如此。我们不希望别人读自己写的函数到一半时就已经不知道函数第一行的目的是什么了。虽然注释能帮助我们读懂代码，但请注意，注释不是除臭剂。只有保持简单性，才可以使函数更易读，易复用，易测试，也易于再次重构。</li>
<li>复杂条件：有着复杂逻辑的代码难以扩展，是大多数程序员的共识。对这类型的代码进行修改，可谓牵一发而动全身。大量的 if-else 头尾相连，构筑出一道铜墙铁壁，给人一副生人勿进的景象。</li>
<li>盲目优化：费尽心思将一个简单的方法从10行代码扩展到了100行，就是为了简化其中的数据拷贝或者别的什么，所带来的效果是将执行耗时从100ms减少到10ms。然而系统的真正的瓶颈却是数据库或是网络请求，这点优化带来的效果微乎其微或者说甚至没有。此时，如果代码变得晦涩难懂，我们也需要考虑是保留还是舍弃本次修改。</li>
<li>出现错误：程序出现错误的原因很多，开发者本身没能完整正确理解自己的设计是其中占比较大的部分。这样的设计，又这么放心让别人去使用呢？亡羊补牢，未为晚矣。有些错误，如果我们能及时对代码进行重构，不仅能对系统进行修复，也可以防患于未然。</li>
<li>过度设计：对未来考虑过多，不仅让设计者忧心忡忡，设计出的系统随着版本迭代也可能会成为累赘，没能发挥应有的作用。凡事讲究适可而止，当学会运用重构这项工具时，我们大可放松心态。考虑未来的同时，更着眼于当下，降低系统的复杂性，同时坦然迎接未来可能的修改。</li>
<li>风格各异：没有统一的编码风格，也会导致代码出现坏味道。对于有争议的部分，不管是哪一方选择妥协，一定要拿出站得住脚的理由，达成一致，然后贯彻下去。</li>
<li>无用代码：面对这种情况，推荐的做法是当机立断，直接删除。因为有版本控制工具的存在，我们不用担心代码丢失，也就没有必要舍不得。</li>
</ul>
<p>以上并非代码崩坏的所有征兆，也很难给出一个完整的列表。但作为程序员，我们几乎都有这样的能力，既能够直接闻出代码的味道。就像一篇文章，一个故事，读了开头我们就大概知道其作者水平如何。</p>
<h2 id="写在最后">写在最后</h2>
<p>选择“重构”这个庞大的主题来做文章，到现在仍旧是惴惴不安。毕竟要真正掌握它，需要大量的编码经验和项目设计经验。代码精进的道路路途遥远，对于我这个刚步入职场不到一年的菜鸟来说，恍若天堑。但千里之行始于足下，纵然步履维艰，也应上下求索。</p>
<p>这将是一个持续更新的系列。我会不断结合书中所学，输出自身对“重构”的理解和实践。最后，非常赞成 Kent Beck 在《重构》一书结尾写的话：</p>
<blockquote>
<p>It's a little like walking along a narrow trail above a one-thousand-foot drop. As long as the light holds, you can step forward cautiously but with confidence. As soon as the sun sets, though, you'd better stop. You bed down for the night, sure the sun will rise again in the morning.</p>
<p>这有点像在悬崖峭壁上的小径行走，只要有光，你就可以前进，虽然谨慎却仍然自信。但是，一旦太阳下山，你就应该停止前进；夜晚你应该睡觉，并且相信明天早晨太阳仍旧升起。</p>
</blockquote>
<p>重构剑法再现江湖，势必掀起一场血雨腥风，到底谁能笑到最后，取得那无上的武学造诣，还无人知晓。就让我们紧跟白衣少年的步伐，去探探隐藏在代码之界背后的秘密。</p>
<p>下一篇文章将从函数的重构技巧说起，不见不散！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[德育中期答辩]]></title>
        <id>https://angus-liu.cn/post/2017-12-18-Morality-defense/</id>
        <link href="https://angus-liu.cn/post/2017-12-18-Morality-defense/">
        </link>
        <updated>2017-12-17T23:46:03.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<h2 id="写在开头">写在开头</h2>
</blockquote>
<p>上午迷迷糊糊的考完安卓，稍作休息（实际上是玩了一会儿游戏），下午便开始准备晚上的“德育中期答辩”。等待快要轮到我答辩时，却因为时间关系，没能有机会分享自己这两年在大学里的经历。回到寝室，躺在床上，开始将自己想要在答辩上分享的话语总结了一下，于是有了下面这篇随感。特此记录下来，希望大学毕业那时，自己再看到这篇文章时能够问心无愧。</p>
<blockquote>
<h2 id="关于成绩收获">关于成绩收获</h2>
</blockquote>
<p>坐在第一排，每一个同学的答辩我都有认真地听完，最后发现，自己和大多数同学一样，很容易找到自己的短板和缺陷，也容易陷入到深深的自责中，但却不去改变现状，不会着手去规划。而是一昧地指责自己，然后幻想着明天的自己能够改变现状。我们总是给自己太多犯错的理由，为自己的不努力找各种各样的借口。等到别人做出了成绩，我们又去羡慕、崇拜乃至嫉妒，只看到表面的辉煌，看不到背后的汗水。大一到大二这两年，仔细想想自己的确经历了一些事情，不算过得很苍白，但就事实说话，却过得并不充实，或者说并不令自己满意。</p>
<h3 id="作为班委"># 作为班委</h3>
<p>大一开学，通过争取当上了班委。那时候其实没有说想要为班级做什么，只是因为自己高中时常常给同学们开个班会课，以为自己能力还行，加上想要在大学里多认识一些人，改变自己在高中时活活像个“屌丝”的窘境。然而真到自己当班委时，却感觉到这其中的不轻松。现在想来那时的自己真得太幼稚，居然会因为要写一个活动策划而差点跟班主任说“不干了”。<br>
回望这两年，也许再没有什么事能比得上自己在“宣传委员兼心理联络员”这个岗位上付出的要多了。策划活动、组织活动、宣传活动到最后活动答辩，自己在这上面轻车熟路，然而这些都没能真正带给我什么。自己从中真正学到的，是如何站在别人的角度思考问题，如何去倾听别人的话语。不过现在有个坏习惯依然改不了，就是跟人聊天时老是控制不住自己的声音，让人觉得太强硬，这或许是我到现在还是没交到多少朋友的原因之一吧。</p>
<h3 id="作为新媒体干事"># 作为新媒体干事</h3>
<p>大一时，自己还加了学生会，在新媒体记者站当一名记者。刚开始什么都不会，犯了各种错误，是萱姐把我带起来的。记得有次期末，部门需要整理文档，萱姐知道我在复习高数就没有安排我去，本应该我们去干的事她一个人揽了下来，可想而知她的考试肯定受到了影响。等我知道这件事的时候，已是大二，看着排的满满的课表，终于理解那时萱姐带我们时的种种忙碌，但她每次都很耐心的指导我，一遍一遍地帮我改稿子。也终于明白为什么我一开始说要继续留在部门当副部时，萱姐一而再，再而三的让我仔细考虑。我想她是知道我是一个慢热型，不善交际的人，继续待在学生会绝对会让我手足无措，到最后，学习和学生会都顾不上。<br>
在学生会的这一年，自己如果真的说自己学到了什么或者收获了什么，那可能就是在同一个部门的朋友以及萱姐给予我的种种帮助。很感谢萱姐最后让我仔细考虑，让我选择一个更适合学习的地方，不然现在的自己也没有机会待在安卓实验室。到现在，自己都会后悔没有早日加入实验室，而是写了一年也许没几个人看的新闻稿。但这段经历真的带给我太多改变，包括对于大学的认知，以及对自己未来的规划，虽然现在看起来那时的规划实在有点可笑。</p>
<h3 id="作为实验室的一员"># 作为实验室的一员</h3>
<p>加入安卓实验室是自己到大学来最明智的决定，自己也很感谢，实验室给了我一个机会，让我看得更高，更远。不过回想自己在实验室待的这几年，自己却没能为实验室贡献出什么，比赛没有优异的成绩，甚至于在初赛就被淘汰，学的也不深，不能把自己学到的知识分享给实验室的其他成员。到了今年暑假才知道自己大概能干点什么，想想的确有点迟了。不过好在，正着手去做，有了一个方向了，剩下的就是努力。</p>
<h3 id="改变的契机"># 改变的契机</h3>
<p>高中老师口中常说的“上了大学你们就不用这么苦了，考试不难，时间自由”，是一开始我对大学的认识。因而，一开始就没有要求自己要在大学做出什么成绩，纯粹一种“做一天和尚撞一天钟”的大学观。虽然考试前自己很努力地复习，有一张漂亮的成绩单，但是也还不明白自己读大学是为了什么。直到大一暑假去继父打工的市场下了二十天左右的货，才开始慢慢明白，自己来大学的目的。母亲右手残疾，弟弟尚且年幼，奶奶满八十高龄，身体多病，继父一个人在水果市场买着苦力，支撑着一整个家庭的运转。自此之后，我不敢再逃一节课，每次上课我几乎都在前三排，纵使课程有时候无聊到让人想要睡觉（虽然自己常常睡着）。读大学的目的，于我来说就是为了让一家人过上更好的生活，仅此而已。</p>
<blockquote>
<h2 id="关于经验教训">关于经验教训</h2>
</blockquote>
<h3 id="如果不喜欢这个专业那一定要找到自己喜欢的方向"># 如果不喜欢这个专业，那一定要找到自己喜欢的方向。</h3>
<p>关于自己是否喜欢这个专业，自己是一直不清楚的，课程都能应付下来，成绩还算马马虎虎，觉得以后当个网工，能有个5000+的工资也不错。直到后来半忽悠半讲究地跟着室友一起去学CCNA/NP校外辅导班，在课堂上不停地打着瞌睡时，才慢慢发现自己不适合网工这个专业。所以后来经历了很长一段时间的煎熬期，不知道自己的方向是什么，不知道自己喜欢什么，不知道自己能够干什么，太多的不知道，淹没了我的理智，甚至一度想到过就这么死了该多好，什么也不用考虑。后来跟班里几个成绩比较好的同学交流，发现他们也会有类似的想法，也经历过这样的时期。说白了，就是因为没有方向，人若没了前进的方向，活得真如行尸走肉。大二暑假，待在学校两个月，整天除了准备比赛就是在思考自己以后该干什么。好在经过一整个暑假，现在的自己渐渐捋清了思绪，知道自己该做些什么。</p>
<h3 id="让自己变得有条理学会归纳总结与分享"># 让自己变得有条理，学会归纳总结与分享</h3>
<p>关于这个，是自己在写笔记时慢慢发现的。如果写笔记时命名很有规律，格式很好，条理清晰，图文搭配得当，那么下次再看自己写的笔记时，就会很容易将遗忘的知识捡起来。后来自己慢慢将这一规律发展到生活中的其他方面，都收到了很好的效果。我也乐于分享自己所学所得，不是显摆自己学到了什么东西，而是带着一股分享的精神，期望找到志同道合的人。我不是什么学霸，更不是什么大牛，如果可以，我希望自己是一个分享者。</p>
<h3 id="懂得感恩多跟父母打打电话"># 懂得感恩，多跟父母打打电话</h3>
<p>到现在，自己仍然有个自己都觉得痛恨的行为。对外人讲话，不管怎么样，我都会耐心地听完，然而一旦跟母亲打电话，我总是大声大气，把最坏的脾气留给了最亲近的人。我没有做到一个儿子该做的职责，没能设身处地为母亲想想。每次通话，母亲想必都是想看看我最近怎么样了，而自己却以上课为理由或者其他草草结束，或是没有心平气和的和母亲交谈。等到挂断电话，自己才明白，我现在的一切都是母亲辛辛苦苦挣来的。母亲没什么文化，她只希望我能读更多的书，不要再去经历那些没文化带来的苦痛，不要像她一样在生活中苦苦挣扎。趁着现在还能有时间，找个机会，我希望自己可以静下心来和母亲好好聊一聊。就今年过年回家的时候吧，我希望自己能够当个合格的儿子。</p>
<h3 id="很多东西说多了自己就会变得麻木"># 很多东西说多了，自己就会变得麻木</h3>
<p>我们总是很会教导别人该怎么做，等到事情落在自己头上时，我们却变得寸步难行。我们常常给自己定一些“宏伟”的目标，制定一些看似可行的计划。可最终呢，那些目标或是计划都随风而散，不留一丝痕迹。我们把注意力过多的放在了“怎么想”，却没有注重“怎么做”。一提到做，自己就变得全身无力，或是不知如何下手。说明白，就是缺乏执行力和自制力。每次的计划都是在一开初就没能好好执行，等过了一段时间，脑海中早已忘记这件事。计划总是赶不上变化，但是做得多比想得好更有效，希望以后的自己，能够明白这一点。</p>
<h3 id="一件事最终没有做成有80是自身的原因"># 一件事最终没有做成，有80%是自身的原因</h3>
<p>暑假时准备参加华北五省，自己一个人在学校待了差不多两个月，结果开学的初赛都没能过。一开始对组长充满了怨言，觉得是他没有带好整个组。但现在反省自身，自己又在这个项目上下了多少功夫呢，恐怕自己是没有资格怪组长的。暑假的自己，发现什么都不会，好多东西都要学习之后，就想着希望组长能够挑大头。正是这样的想法，成为了我们失败的开端。我们总是觉得别人该做什么，却没想过自己该做什么，自己缺什么。而是带着一种能偷懒就偷懒的想法，打着擦边球，这样的我们是不会有什么成长的。只有勇于承担，敢于挑战，自身才会得到更好的发展，也才能够给团队带来更好的结果。现在明白了这一点之后，我也开始沉浸下来，巩固自己的不足。希望以后的自己，能够面对自己的短板，不迁怒于他人。去总结失败的原因，着手去更正，而不是一昧的怪罪他人，什么也不做，一事无成。</p>
<h3 id="世上没有怀才不遇这件事"># 世上没有怀才不遇这件事</h3>
<p>偶然看见这句话，是一本书的名字。我们常常说怀才不遇，那是建立在过去那个信息闭塞的年代。但如今，互联网将整个地球链接在了一起，如果一个人在这样的环境下还“不遇”，那这个人肯定不是“怀才”而是“无才”。这句话也让我明白，在如今，不再是伯乐去寻千里马，而是千里马主动去寻伯乐。这不再是过去那个千里马少有的时代了，我们必须不断地扩充自己，各方面的发展自己，在以后的工作中才有可能胜过其他竞争对手，才有可能被赏识。特别是自己学的还是计算机，技术迭代的速度越来越快，稍不留意，就会掉到队伍的末尾，甚至掉下车。所以要想进入到更好的环境学习和工作，首要的，我们需要让自己变得有足够的才能。位置就那么多，优秀的人先上座。</p>
<h3 id="每次关掉闹钟想着再睡十分钟的时候"># 每次关掉闹钟想着再睡十分钟的时候……</h3>
<p>5:40开始响起的闹钟，关掉一个又一个，真正起床时已经快8点了，这作息让每次起床的自己的内心都充满了罪恶感。很佩服学习委员，一个女生，每天能够在6:20前起床，每天都能按时执行自己的计划，健身，背单词，然后微笑着面对每一天。表面上，我和她的差距就是这每天晚起的两个小时。实际上，我和她差了太多，包括这股坚持的精神。就坚持而言。可能我们大多数男生都没有女生做的到位，除了玩游戏。如果时光耗费在被窝里，那最后的自己就只会死在温床上。从明天开始，我希望自己能够准时履行自己的计划，按时起床，开始着手去改变自己，而不是包容自己。</p>
<blockquote>
<h2 id="关于心灵感悟">关于心灵感悟</h2>
</blockquote>
<p>很庆幸到现在自己还保持着阅读的习惯，也正是这样，自己才会在思想上慢慢成长。网购了那么多次，唯有电子书是自己买的最有价值的东西。或许我的人生枯燥无味，一成不变，但阅读使我的人生充满了各种可能。我很感激那个在三年级时就喜欢跑书店的自己，那个一看书连饭都会忘了吃的自己。阅读不仅仅给予我知识与宁静，书中的种种哲理也在慢慢影响着我为人处事的原则。从某方面讲，我现在能够在公众场合比较自然的发言，也是阅读带给我的好处。所以关于心灵感悟，一句话，我们应该多读书。什么类型的书都不要挑，名著要读，小说也要看，人物传记、鸡汤文，遇到挫折时翻一章，旅行趣事、国家地理，为束缚住的内心开一扇自由的天窗……</p>
<blockquote>
<h2 id="关于规划展望">关于规划展望</h2>
</blockquote>
<p>关于明确的规划自己其实是没有的，如果非要从读研还是就业来看，我更倾向于后者。一方面自己实在找不到喜欢研究的方向（也或许是自己没有去主动找过），再者我希望自己能早日步入社会，为家里减轻一点负担。父母衰老得很厉害，弟弟又成长得很快。也许过几年，我就得撑起一整个家。我现在必须明确这些，不能逃避。我希望自己能学会满足，但也学会不满足，继续保持读书的习惯，不断的提升自己，不忘记母亲鬓角的皱纹，做一个甘于在路边鼓掌，亦敢于像野马一样奔驰的人。不管以后从事什么行业，做什么工作，我都必须认真且负责的完成，做一个值得他人信赖的人。</p>
<blockquote>
<h2 id="写在最后一些小目标">写在最后，一些小目标</h2>
</blockquote>
<p><font color="#F85959"><b>1.早上6:10起床，晚上11:30准时睡觉。<br>
2.每天学一小时英语，形式不限（主要还是流利说）。<br>
3.每天练一小时标准指法打字，每天一小时书法练字 → <a href="https://www.typingclub.com/">指法网站</a>。<br>
4.一周至少看完一本书，并写好读后感。<br>
5.每周至少更新一次博客。<br>
6.为即将到来的事情，做好一周的准备。<br>
7.慢慢的割舍掉已有的坏习惯。<br>
8.未完待续……</b></font></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二十一克]]></title>
        <id>https://angus-liu.cn/post/2017-04-17-21-grams/</id>
        <link href="https://angus-liu.cn/post/2017-04-17-21-grams/">
        </link>
        <updated>2017-04-17T12:10:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="二十一克-灵魂之重">二十一克-灵魂之重</h1>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=27646198&auto=1&height=66"></iframe>
<blockquote>
<h2 id="皮囊">皮囊</h2>
</blockquote>
<p>有时候，我常常会这样想。<br>
大学毕业后，自己要去干什么。<br>
没有目标，也没有梦想，只有生活，必须要面对的生活。<br>
在班里，自己整天嘻嘻哈哈，成绩在这个普通学校里貌似看起来还算可以。<br>
但常常发现，自己所做的事，往往都不是自己想做的。<br>
有的是为了自己的毕业单漂漂亮亮，有的则是将自己伪装成一个热心的好人。<br>
不止一次，自己对自己的外表感到厌倦，甚至恶心。<br>
但这件外衣，自己怕是很难脱掉了，连着皮，连着肉，连着与内心无关的一切。</p>
<blockquote>
<h2 id="命题">命题</h2>
</blockquote>
<p>有时候感到很累，感到周围的一切都如此苍白。<br>
但是又好似什么东西在推着我，一直不停地在往前。<br>
我知道未来我应该做什么，自己也正朝着那个方向努力。<br>
但如果有机会，我想下了这趟快车，在一个山清水秀的地方，孤独的老去。<br>
人的确该为了某些东西在这个世界坚强的活下去，但也的确该为了别人活下去去做一些事情。<br>
这是个很矛盾的命题。</p>
<blockquote>
<h2 id="董小姐">董小姐</h2>
</blockquote>
<p>如果我老了，我曾这样想过。<br>
和相爱的人，在一个不起眼的巷子里，开一家书店。<br>
书店里堆满了书，供人们阅读，但是不卖，书离开了书店就不再是书了。<br>
我们会在书店中央摆上沙发，茶几。<br>
顾客来了，就相逢坐下，彼此谈论感兴的话题。<br>
或者靠在窗台，点一杯店里的咖啡，慵懒的过一个下午。<br>
每逢周日，店里举办书会。<br>
有民谣歌手过来唱他的董小姐，我们聚在一起，交换着彼此的故事。</p>
<blockquote>
<h2 id="勉强的生活">勉强的生活</h2>
</blockquote>
<p>但是我还没有相爱的人，我也没钱开这样一家书店。<br>
在一个小时前，我还在调试着代码，过着枯燥的一天。<br>
老师说我们这个专业出去的人大多都成为了码农，然后在四十岁就失业。<br>
接下来的时间，就是勉强着靠着以前的储蓄，过着勉强的生活。<br>
想想的确很可怕，但这就是事实，不可辩驳。</p>
<blockquote>
<h2 id="平淡">平淡</h2>
</blockquote>
<p>好吧，我感觉自己是斗不过现实的，要是运气好那就另说了。<br>
我只想未来自己能有一个安稳的生活，薪水不要求多少。<br>
能让我陪妻子出去看看，能让我女儿追逐她的理想，就够了。<br>
也许我应该有更伟大的理想的，但经历了许多后，明白了妈常说的平平淡淡才是真。</p>
<blockquote>
<h2 id="二十一克">二十一克</h2>
</blockquote>
<p>现在是四月十七，离我成为大三生还有两个月，离毕业还有两年。<br>
我还有足够的时间去幻想自己的未来，然后每到夜晚，蜷缩成刚到这个世界的样子。<br>
有人说，每个人死的时候都会失去二十一克的重量，这就是灵魂的质量。<br>
二十一克，有所多少克里描绘着我们的人生，又有多少克离合悲欢。<br>
没有人知道，也不会有人知道。<br>
我们都在这世界，乞求着这世界的认可。<br>
如果非要说这世界给予了我们什么，我觉得，那一定是你我所正在经历的生活。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[过年（写于节后）]]></title>
        <id>https://angus-liu.cn/post/2017-02-06-Spring-Festival/</id>
        <link href="https://angus-liu.cn/post/2017-02-06-Spring-Festival/">
        </link>
        <updated>2017-02-06T11:25:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="过年">过年</h1>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=436514312&auto=1&height=66"></iframe>
<blockquote>
<h2 id="宿舍">宿舍</h2>
</blockquote>
<p>考完试，在学校待了八九天。<br>
因为错过了留宿申请的时间，没办法在学校待太久。<br>
简单地收拾了下行李，跟寝室里因为工作晚回的哥们儿道了别。<br>
拉着行李箱，走出寝室楼前照例向宿管阿姨问了声好。<br>
阿姨看着我，知道我今天回去，一个劲叮嘱我路上小心。</p>
<blockquote>
<h2 id="车厢">车厢</h2>
</blockquote>
<p>车厢实在闷的很，走到车门处，清冷的空气呼啸而入。<br>
21个小时，车窗外的风景从北方换成了南方。<br>
一路上，乘客上上下下。<br>
到成都时，偌大的车厢，空空荡荡。<br>
妈已在车站，接过我拖着的行李箱，放在车上。<br>
妈把车把交给我了，让我在这个城市驰骋。<br>
昏暗中的成都有种迷人的味道，让人快要醉倒而迷失方向。<br>
可能再不会有这样的机会，能让我如此轻松地回家。</p>
<blockquote>
<h2 id="母亲">母亲</h2>
</blockquote>
<p>父母都在变老，老得很厉害。<br>
一个恍惚，妈老成了外婆的样子。<br>
2016，这一年，妈没有闲着。<br>
和着三姨，妈把一个水果市场的卫生承包了下来。<br>
妈说她没有管理的头脑，所以她和三姨没有请人，决定自己干。<br>
还未回家，妈就在电话里讲：“过年回来帮我扫两天地，体会一下挣钱的辛苦。”<br>
我：“呃，行。”</p>
<blockquote>
<h2 id="选择">选择</h2>
</blockquote>
<p>扫地的时候，头里必须想些什么。<br>
不然四五个小时连续不停的挥动扫把很容易让人联想到世界末日。<br>
但我好歹是个会自娱自乐的人，心里总会乱想些什么。<br>
妈说她不会，想着想着就会睡着，连扫地的时候都会睡着。<br>
我问妈：“要是你有一家饭馆，自己干的话一个月能有5000的净利润，要是你请一个厨子一个月要付他4000的工资，而你什么都不用干，你选择怎么做？”<br>
妈选择了前者，没说原因，光说了句：“快扫，不然待会又要扫到凌晨两点。”<br>
同一个问题，问表妹时，她果断选择了后者。</p>
<blockquote>
<h2 id="表妹">表妹</h2>
</blockquote>
<p>表妹的2016年，是蜕变的一年，不像蛹化蝶，像雪化雨。<br>
每一次电话，表妹会说她最近学会了烤什么面包，做什么慕斯。<br>
二妹怎么怎么烦她，她一个18岁的女孩就开始边打工边带孩子的生活。<br>
她说师傅现在就她一个亲传弟子，在很用心的教她。<br>
她也跟师傅说过她的缺点就是懒，还有就是数学不好。<br>
师傅说她知道自己是这样，证明她还不笨。<br>
躺在床上，她跟我说，等上班她要打三个耳洞，等以后要纹一个动物的纹身。<br>
等几年以后，在乐山一个安静的角落，开一家安静的面包店。<br>
她不喜欢成都的喧嚣，感觉这个城市让她很压抑。<br>
其实成都也有安静的角落，不过表妹的故乡是乐山。<br>
故乡在每个人心里，都是最安静的，未曾喧嚣。</p>
<blockquote>
<h2 id="同学会">同学会</h2>
</blockquote>
<p>今年又错过了同学会。<br>
初中时的班长打电话来时正准备服从妈的旨意，回去继续上岗。<br>
高中时的班长发来聚会消息时已经待在学校，太远的距离就像一堵墙。<br>
好在幸运的，去了一趟兄弟的家，算是拜年吧。<br>
好在幸运的，我们六个还是找机会聚在了一起，仍旧谈论着去年的话题。<br>
找了一家餐厅，过了小年，吃光抹净后才突然想起去看看老大。</p>
<blockquote>
<h2 id="老大">老大</h2>
</blockquote>
<p>远远得，老大站在那里，还像记忆中站在讲台上的她，岁月对老大很是温柔。<br>
老大：“你们可好，读大学后没来我这报道一下，我还四处去问。”<br>
六个人连忙自报家门。<br>
老大：“要是没谈过一场恋爱，没出去走走，大学就荒废啦。”<br>
我：“我的大学已经荒废了。”<br>
老大：“可能再过几年就会忘了你们叫什么名字了。”<br>
我们：“我们是不会忘了你的，永远都不会。”<br>
初中时老大交给我的道理，到现在仍然受用。<br>
也许会受用一辈子。</p>
<blockquote>
<h2 id="兄弟">兄弟</h2>
</blockquote>
<p>除夕夜，我们依旧是聚在一起。<br>
初三毕业后这一习惯就没有变过，像是约定俗成。<br>
兄弟开了六瓶酒，说是一人一瓶，五个人笑谈说没来的那个兄弟给他敬上。<br>
我说我不会喝酒，一喝就得脸红。<br>
兄弟说:“怕啥，喝一杯”。<br>
喝一杯，这辈子的友情才不会被岁月冲淡。</p>
<blockquote>
<h2 id="豆腐皮">豆腐皮</h2>
</blockquote>
<p>初一的夜晚，早早地叫豆腐皮睡觉。<br>
熄灯前豆腐皮一个劲地问我，什么时候他才能有自己的游戏机。<br>
我说：“等你上了小学，上了初中，有能力克制自己并且学习成绩好的时候。等你考上了重点大学，哥还会给你买最贵的游戏笔记本。”<br>
豆腐皮又问：“什么是重点大学，是不是你贴在墙上的那些？”<br>
我：“恩。墙上贴的清华、北大都是。”<br>
豆腐皮：“重点大学有什么好？”<br>
我：“有我给你准备的游戏电脑，至于其他的好处，等你长大就知道了。”<br>
豆腐皮：“那我要考最好的重点大学，要考上清华和北大。”<br>
我：“睡吧，哥相信你会的。”</p>
<blockquote>
<h2 id="奶奶">奶奶</h2>
</blockquote>
<p>离别前的一晚，奶奶和我促膝长谈。<br>
她跟我说因为粮食关，她的好多亲人都在饥饿中死去，死时嘴里含着一大口棉絮。<br>
她跟我说小时候因为裹脚太疼，即使家里人怎么骂她，打她，她都没有裹脚。<br>
她跟我说你要好好读书，我们吃够了苦，但不想你和你弟弟再吃苦。<br>
她说：“八十岁是一个坎，不知道我今年能不能跨过去。”<br>
我：“奶奶，你要等到豆腐皮读大学，你会等到的。”<br>
奶奶，你怎么会过不去，你还没享过几天福。<br>
等以后，我还想带着我妈和你，带着咱一家出去走走。<br>
还想听听你讲的那些故事。</p>
<blockquote>
<h2 id="写在最后">写在最后</h2>
</blockquote>
<p>以前总认为生活要好好规划，但猛然察觉，现在的生活，又有哪一步是我以前所规划过的。<br>
不过是每一次意外的结果，让我选择了这样的生活。<br>
有好有坏。<br>
最大的好，是遇到了这些人。<br>
每一年都感觉过年变得越来越没意思。<br>
但每一次除夕夜，我们都像过去那样袒露着自己。<br>
路灯下的我们重叠在一起，未曾分离。</p>
]]></content>
    </entry>
</feed>